MAU 1위인 이베이 트래픽 기준
평균 1시간 상태 업데이트 물품 = 약 20만 건


## 고민1: 경매 상태 자동 업데이트 방식
### 문제점
  - 경매가 종료되는 시점에 맞춰 상태를 자동으로 'ONGOING'에서 'ENDED'로 변경해야 함
  - 현재는 별도의 API(`PATCH /api/auctions/{id}/end`)를 호출해야 상태가 변경됨
  - 수많은 경매가 동시에 종료될 경우 일일이 API를 호출하는 것은 비효율적

### 선택지1: CDC(Change Data Capture) 활용 - 선택x
- Debezium과 같은 CDC 도구를 사용하여 경매 종료 시간이 도달했을 때 데이터베이스 변경 이벤트를 감지
- 감지된 이벤트를 기반으로 상태를 'ENDED'로 변경하는 프로세스 구현
#### 장점
- 변경 이벤트 발생 즉시 상태 업데이트 가능
#### 단점
- CDC 도구 설정 및 운영의 복잡성 증가
- 추가 인프라 비용 발생
- 경매 종료 직후 상태가 바로 반영되지 않을 수 있음
#### 선택하지 않은 이유
- 경매 특성상, 정해진 종료 시간이 초단위가 중요하지 않음
- 경매 종료 시점을 분단위로 강제화 한다면 스케줄러로 충분
- CDC의 복잡성을 감수할 필요 없음 

### 선택지2: 스프링 스케줄러 기반 폴링
스프링의 @Scheduled 어노테이션을 사용하여 1분 주기로 종료 시간이 지난 경매를 찾아 상태를 'ENDED'로 일괄 업데이트하는 배치 작업 구현
#### 장점
- 구현이 매우 간단하고 추가 인프라 불필요
- 10초 주기는 경매의 분/초 단위 종료 시간에 충분한 즉각성 제공
- 유지보수가 간편
#### 단점
- 대용량 데이터를 단일 트랜잭션으로 처리하면 DB 락이 발생하므로, 개발자가 직접 Paging 등을 통해 청크 단위 로직을 구현해야 합니다.
- 100만 건 중 50만 건 처리 후 서버가 다운되면, 어디서부터 다시 시작해야 할지 추적하는 로직을 직접 구현해야 합니다.
- 1건의 오류가 전체 배치를 멈추게 할 수 있습니다. 이를 방지하기 위한 Skip이나, 일시적 DB 오류를 위한 Retry 로직을 try-catch로 직접 구현해야 합니다.
- 작업이 성공했는지, 실패했는지, 몇 건을 처리했는지 확인하기 위한 모니터링 및 로깅을 모두 수동으로 구현해야 합니다

### 선택지 3: 스프링 스케줄러 + 스프링 배치 (Spring Batch) - (최종 채택)
선택지 2와 같이 스프링 스케줄러를 사용하되, 단순 서비스 메서드가 아닌 스프링 배치 잡(Job)을 트리거합니다.
배치 로직:
Reader: 종료 시간이 지난 경매(status = 'ONGOING' AND end_time <= NOW())를 Cursor 또는 Paging 방식으로 읽어옵니다. 
Processor: (선택적) 읽어온 경매 객체의 상태를 'ENDED'로 변경합니다.
Writer: Chunk 단위(e.g., 100건)로 데이터를 묶어 DB에 UPDATE합니다.
#### 장점
- 대용량 데이터 처리 시 필수적인 재시작성, 에러 핸들링(Retry/Skip), 모니터링(Job Repository) 기능을 프레임워크가 기본 제공합니다.
- 선택지 2의 단점인 운영 로직들을 개발자가 직접 구현할 필요가 없습니다.
#### 단점
- 학습 곡선이 있음

### 최종 선택 및 사유: 선택지 3 (스프링 스케줄러 + 스프링 배치)
- 선택지 2(수동 구현) 방식은 청크 처리를 수동으로 구현하더라도, 장애 상황에서의 재시작성 보장, 데이터 오류 발생 시 Skip/Retry, 작업 이력 모니터링 등 운영에 필수적인 기능들을 모두 개발자가 직접 구현해야 하는 큰 부담이 있습니다.
  따라서 이미 검증된 배치 프레임워크인 스프링 배치를 채택하여, 이러한 복잡한 운영 로직을 프레임워크에 위임하고 비즈니스 로직에만 집중합니다.
### 부가적으로 결정한 사항
- 스케줄러 방식(2, 3)이나 이벤트 방식(1) 모두 경매 종료와 상태 변경 간의 약간의 시간차는 필연적으로 발생합니다.
따라서 종료된 경매에 입찰을 막는 핵심 비즈니스 로직은 스케줄러에 의존하지 않고, **입찰 API** (POST /api/bids) 내부에서 현재 시간과 **경매 종료 시간을 비교하여 차단**하도록 구현합니다.
- **클라이언트 단에서는 경매 종료 시간이 지나면 입찰 버튼을 비활성화**하여 사용자 경험(UX)을 보완합니다.
상태 변경 작업은 약간 늦어져도 괜찮지만, 대량의 데이터를 **안정적으로 처리**하는 것이 가장 중요해집니다.


### 고민2: 복제 지연 문제
### 문제점
- 마스터-슬레이브 구조에서 복제 지연으로 인해 슬레이브 DB에서 최신 경매 상태가 반영되지 않을 수 있음
- 읽기 요청이 슬레이브 DB로 분산될 때, 사용자가 오래된 경매 상태를 조회할 위험
- 특히 경매 종료 직후 상태 조회 시 문제가 발생할 수 있음
### 해결책1: 읽기 일관성 보장
- 경매 상태 조회 API에서 최신 상태가 필요한 경우, 마스터 DB에서 직접 읽기
- 예: `GET /api/auctions/{id}` 요청 시 마스터 DB에서 조회
### 장점
- 최신 데이터 보장
### 단점
- 마스터 DB 부하 증가
- 확장성 저하

## 고민3 마스터가 다운되었는 데 요청이 몰리고 슬레이브가 주인이 되었는데 마스터가 다시 주인이 되었을 때는?
